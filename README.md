# jP's Canvas JS Utilities

This was a small piece of a larger term project I made for my JavaScript class at NMC. The project involved making 3 JavaScript web games with at least one of the 3 using the HTML5 canvas. In addition, we were not able to use any game engines or other tools that would have taken us away from using pure Javascript or JQuery. I took some of the lessons I learned in building the C++/DirectX game engine from before attending NMC and applied them to this. I built an object-oriented mini framework for rendering canvas games (or any 2D canvas creation). It has numerous features for assembling a game scene and has been optimized well enough to run on a chromebook in most cases. With this I was able to build two different games with vastly different design needs on the same platform. The platform was so reliable, I was able to complete the second game (a simplified version of Tetris) over the course of a single weekend! I am writing this post-mortum almost two years later, so some details may be fuzzy.

## Features:
* Master Game Object - This is the core of a game using this mini-framework. The master game object controlls the timing, clearing/rendering of frames, IO opperations, collision detection, and more that I'm probably forgetting after nearly two years.
* Foreground Objects - This served as a base object for any elements the player with (including the player themselves) or elements that need to process information between frames (such as invisible bariers that need to check collisions). These objects could be defined as primative colored boxes or load asset images and even handle sprite sheet based animations!
* Background Objects - This served as a base object for any elements that need to be rendered to the screen but don't require any processing of data between frames.
* Collision Detection - Between each frame, the MGO (Master Game Object) checks to see what foreground objects are overlapping and registers them in an array of collisions that the objects can then reference to see what collisions they are experiencing and respond accordingly. Because collisions happen in pairs, it also skips checking duplicate collisions to save resources.
* Inteligent Resource Loader - When an object makes a request to load a resource from file, it first checks a list of all loaded resources to see if that resource is already loaded. If it is, rather than loading the resource again, it borrows the resource from the other asset instead of reloading them.

## What went right:
* Object-oriented modular design - I was very pleased how this turned out. I was able to make two different games that worked in very different ways with little change to the underlying technology. I could see this (and after reviewing it, I may add to it) little project being easily extended or built upon.
* Well organized - Although this uses some fairly primative JavaScript (compared to my current abilities), the code is well organizzed in a way that I can (even two years later) make sense of what is happening. Comments are used where needed and everything makes logical sense.
* Fairly well optimised - I developed this mini-framework on a newly purchased gaming laptop that was not representative of the average user's PC. For this reason, I made sure to perfomance test on my Chromebook. This allowed me to establish that on average, framerates would remain consistant until at least 600-800 entities were present on screen depending on what those entities were doing! I thought this was pretty good for something I developed by myself in just a few weeks.
* Intelegent Resource Loader - This was such a simple addition, but so important for performance! I was so happy with how well this simple system worked!

## What I could have improved:
* Garbage collection options - As it stands, this game has no way of clearing unused assets. This means that any sprite asset that is not being used will remain in memory until the page is reloaded. This is fine for small games, but more complex games with could suffer performance issues. This could be handled with a "last one out" automated GC or a simple option to manually tell the MGO to delete an asset.
* More centralized resource management - there were some things that were handled by individual assets that could have been more effecient if centralized as part of the MGO. Each foreground object checked collisions when prompted by the MGO as opposed to the MGO doing a master check for collisions on it's own. The intelegent resource loading system was also handled within the sprite object instead of through the centralized MGO. In practice this worked well enough, but it did make the code feel more clunky than it needed to in certain areas.
* I would have liked to add a sound management system to handle loading and playing audio files on demand.
