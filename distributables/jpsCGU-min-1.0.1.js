/** * @preserve * Core controller class of the game. Handles all settings, timings, and orchestration of game entities. */
class GameCore{
    /** *@preserve * @type {Array.<string>} Protected members that can not be overridden by the initializer options! */
    static protectedKeys=["protectedKeys","paper","pen","nextId","getUniqueId","init","interval","scenes"]
    /** * @preserve *@type {HTMLCanvasElement | null} The HTML5 canvas the game will be rendering to. */;paper;
    /** * @preserve *@type {CanvasRenderingContext2D | null} Canvas context for rendering content to canvas */
    pen;
    /** * @preserve *Size of the canvas. */
    paperSize={width:width,height:height}
    /** * @preserve *@private {number} Tracks the next entity Id to be assigned. IMPORTANT! DO NOT ASSIGN DIRECTLY FROM THIS! Use the * AssignId method to ensure this counter is incremented properly and all entities have a unique * Id associated with them! */;static nextId=0;
    /** * @preserve *@type {number} Frames per second */
    framerate=60;
    /** * @preserve *@type {number} Number of frames rendered. Used for tracking actual framerate delivered and for actions that * happen every n number of frames */
    framesCount=0;
    /** * @preserve *@type {number} interval Id used to stop the game loop if needed */
    interval;
    /** * @preserve *@type {string} Color string defining the desired default color */
    backgroundColor="white";
    /** * @preserve *@type {Array.<Scene>} Individual scenes that make up a game. At least * one scene must be added to the gameCore for any functionality. */
    scenes;
    /** * @preserve *@type {number} Index number of the current scene. */
    currentScene;
    /** * @preserve *@type {Array.<InputAction>} Bound inputs currently being tracked. */
    inputQueue;
    /** * @preserve *Gets a unique identifier for an entity. * @returns {number} */
    getUniqueId(){let id=GameCore.nextId;return GameCore.nextId++,id}
    /** * @preserve *Creates and initializes a new GameCore instance with the provided options * @param {string} canvasId HTML id tag used to target the canvas * @param {GameSettings | Object.any} options object containing any number of options that you would like to set. NOTE: * options MUST contain a width and height key-value pair to initialize properly. Even if they are set to null! It is * recommended you use the GameSettings as a base for any options you would like to add as opposed to a generic JS * object. * @returns {GameCore | null} */static init(canvasId,options=new GameSettings){var game=new GameCore;try{game.paper=document.getElementById(canvasId),"HTMLCanvasElement"!=typeof game.paper&&console.log(`Element with id "${canvasId} is of type ${game.paper.tagName} not canvas. Please check spelling and select a canvas element."`)}catch(error){return console.log(`Faild to locate canvas with id "${canvasId}" please verify spelling.`),console.info(error),null}if(!options.width||!options.height)return null;null!==options.width&&(game.paperSize.width=game.paper.width),null!==options.height&&(game.paper.height=options.height),game.paperSize.height=game.paper.height,game.paperSize.width=game.paper.width,delete options.width,delete options.height;for(const[key,value]of Object.entries(options))GameCore.protectedKeys.includes(key)?console.log(`The member '${key}' is a foundational component of GameCore and cannot be overwritten! Please select a new name for the key`):(game[key],game[key]=value);return game.pen=game.paper.getContext("2d"),game.interval=setInterval(game.gameLoop,1e3/game.framerate),game}gameLoop(){this.scenes&&!this.currentScene?this.currentScene=0:(clearInterval(this.interval),console.log(`GameCore associated with canvasId:${this.paper.id} crashed: No scenes defined!`));var startDE=[],afterInputDe=[],endDE=[];this.scenes[this.currentScene].entities.dataEntities.forEach((dataEntity=>{switch(dataEntity.procLocation){case procLoc.start:startDE.push(dataEntity.proc);break;case procLoc.afterInput:afterInputDe.push(dataEntity.proc);break;case procLoc.end:endDE.push(dataEntity.proc)}})),startDE.forEach((proc=>{"function"==typeof proc&&proc()})),this.inputQueue.forEach((action=>{action.proc(),action.complete&&this.inputQueue.splice(this.inputQueue.indexOf(action),1)})),afterInputDe.forEach((proc=>{"function"==typeof proc&&proc()})),this.pen.fillStyle=this.backgroundColor,this.pen.fillRect(0,0,this.paperSize.width,this.paperSize.height),this.scenes[this.currentScene].proc(),this.scenes[this.currentScene].render(),endDE.forEach((proc=>{"function"==typeof proc&&proc()})),this.scenes[this.currentScene].entities.resoruces.forEach((resource=>{resource.proc()})),this.framesCount++}}class GameObjectBase{
    /** * @preserve *Unique identifier for this scene * @type {number} */
    uId;
    /** * @preserve *Game the object belongs to. * @type {GameCore} */
    gameCore;
    /** * @preserve *@abstract * @type {function | null} Process the entity frame */
    proc=null;
    /** * @preserve *@abstract * @type {function | null} Render entity frame if it is renderable. When set to null this call will be ignored. */
    render=null;
    /** * @preserve *Base constructor for all game objects. Ensures child classes have access to the GameCore object they belong to * and a uniqueIdentifier * @param {GameCore} game GameCore that this entity belongs to. */
    constructor(gameCore){this.gameCore=gameCore,this.uId=GameCore.getUniqueId()}}class GameSettings{
    /** * @preserve *Width of the canvas, if set to null, the width of the canvas will be the width defined in * the HTML/CSS for the page * @type {number} */
    width=null;
    /** * @preserve *Height of the canvas, if set to null, the height of the canvas will be the height defined in * the HTML/CSS for the page * @type {number} */
    height=null;
    /** * @preserve *Color string defining the desired default color * @type {string} */
    backgroundColor="white";
    /** * @preserve *Frames per second * @type {number} */
    framerate=60}function CreateGameMaster(targetID){try{this.paper=document.getElementById(targetID)}catch(err){return console.log("Failed to initialize canvas. Try checking the spelling of your targetID."),void console.info(err)}this.pen=this.paper.getContext("2d"),this.interval=null,this.gameForegroundObjects=[],this.gameBackgroundObjects=[],this.framerate=60,this.framesCount=0,this.backgroundColor="white",this.objectID=1e3,this.init=function(options={width:"default",height:"default"}){NaN!=options.width&&options.width>0&&(this.paper.width=options.width),NaN!=options.height&&options.height>0&&(this.paper.height=options.height),options.framerate&&(this.framerate=options.framerate),options.backgroundColor&&(this.backgroundColor=options.backgroundColor);var tmp=this;this.interval=window.setInterval((function(){tmp.gameUpdate(tmp)}),1e3/this.framerate)},this.gameUpdate=function(game){game.pen||(console.log("Your pen's outta ink mate..."),game.interval.stopInterval()),game.pen.fillStyle=game.backgroundColor,game.pen.fillRect(0,0,game.paper.width,game.paper.height);for(let i=0;i<game.gameBackgroundObjects.length;++i)game.gameBackgroundObjects[i].drawFrame(game);for(let i=0;i<game.gameForegroundObjects.length;++i)game.gameForegroundObjects[i].checkCollisions(game),game.gameForegroundObjects[i].updateFrame(game),game.gameForegroundObjects[i].drawFrame(game),game.gameForegroundObjects[i].markForRemoval&&(game.gameForegroundObjects.splice(i,1),i--);this.drawOverlay(),this.framesCount++},this.drawOverlay=function(){},this.reindexBGObjects=function(){for(let i=0;i<this.gameBackgroundObjects.length;++i)this.gameBackgroundObjects[i].index=i}}function GameBGObject(Game,x,y,width,height,options={color:"black"}){this.uniqueID=Game.objectID,Game.objectID++,this.x=x,this.y=y,this.width=width,this.height=height,this.GameObject=Game,this.color=options.color,this.desciption="",this.drawFrame=function(GameObject){GameObject.pen||(console.log("Your pen's outta ink mate..."),GameObject.interval.stopInterval()),GameObject.pen.fillStyle=this.color,GameObject.pen.fillRect(this.x,this.y,this.width,this.height)},this.moveUp=function(){if(this.index===this.GameObject.gameBackgroundObjects.length-1)return console.log("BackgroundObject #"+this.uniqueID+" is already at the top of the render stack!"),void console.info(this);var tmp=this.GameObject.gameBackgroundObjects[this.index+1];this.GameObject.gameBackgroundObjects[this.index+1]=this,this.GameObject.gameBackgroundObjects[this.index]=tmp,this.GameObject.gameBackgroundObjects[this.index].index=this.index,this.index++},this.moveDown=function(){if(0===this.index)return console.log("BackgroundObject #"+this.uniqueID+" is already at the bottom of the render stack!"),void console.info(this);var tmp=this.GameObject.gameBackgroundObjects[this.index-1];this.GameObject.gameBackgroundObjects[this.index-1]=this,this.GameObject.gameBackgroundObjects[this.index]=tmp,this.GameObject.gameBackgroundObjects[this.index].index=this.index,this.index--},this.moveBefore=function(targetID){var targetIndex="unknown object";for(let i=0;i<this.GameObject.gameBackgroundObjects.length;++i)if(this.GameObject.gameBackgroundObjects[i].uniqueID===targetID){targetIndex=i;break}"unknown object"===targetIndex&&console.log("failed to locate GameBGObject #"+targetID+" please make sure you entered the correct ID."),this.GameObject.gameBackgroundObjects.splice(this.index,1),0===targetIndex?this.GameObject.gameBackgroundObjects.unshift(this):this.GameObject.gameBackgroundObjects.splice(targetIndex,0,this),this.GameObject.reindexBGObjects()},this.moveAfter=function(targetID){var targetIndex="unknown object";for(let i=0;i<this.GameObject.gameBackgroundObjects.length;++i)if(this.GameObject.gameBackgroundObjects[i].uniqueID===targetID){targetIndex=i;break}this.GameObject.gameBackgroundObjects.splice(this.index,1),"unknown object"===targetIndex&&console.log("failed to locate GameBGObject #"+targetID+" please make sure you entered the correct ID."),targetIndex===this.GameObject.gameBackgroundObjects.length-1?this.GameObject.gameBackgroundObjects.push(this):this.GameObject.gameBackgroundObjects.splice(targetIndex,0,this),this.GameObject.reindexBGObjects()},this.GameObject.gameBackgroundObjects.push(this),this.index=this.GameObject.gameBackgroundObjects.length-1,options.desciption&&(this.desciption=options.desciption),"function"==typeof options.drawFrame&&(this.drawFrame=options.drawFrame)}function GameFGObject(Game,x,y,width,height,options={}){this.uniqueID=Game.objectID,Game.objectID++,this.GameObject=Game,this.x=x,this.y=y,this.width=width,this.height=height,this.type="",this.overlapObjects=[],this.color="black",this.checkCollisions=function(Game){this.overlapObjects=[];for(let i=0;i<Game.gameForegroundObjects.length;++i){let skip=!1;if(this.uniqueID==Game.gameForegroundObjects[i].uniqueID&&(skip=!0),!skip){let c=Game.gameForegroundObjects[i];this.x<c.x+c.width&&this.x+this.width>c.x&&this.y<c.y+c.height&&this.height+this.y>c.y&&this.overlapObjects.push(Game.gameForegroundObjects[i])}}},this.updateFrame=function(){return!1},this.drawFrame=function(Game){this.preDrawFrame&&"function"==typeof preDrawFrame&&this.preDrawFrame(),Game.pen.fillStyle=this.color,Game.pen.fillRect(this.x,this.y,this.width,this.height),this.postDrawFrame&&"function"==typeof postDrawFrame&&this.postDrawFrame()},Game.gameForegroundObjects.push(this),this.index=Game.gameForegroundObjects.length-1,this.markForRemoval=!1,this.remove=function(){this.markForRemoval=!0},this.moveUp=function(){if(this.index===this.gameForegroundObjects.length-1)return console.log("ForegroundObject #"+this.uniqueID+" is already at the top of the render stack!"),void console.info(this);var otherFGO=this.GameObject.gameForegroundObjects[this.index+1];this.GameObject.gameForegroundObjects[this.index+1]=this.GameObject.gameForegroundObjects[this.index],this.GameObject.gameForegroundObjects[this.index]=otherFGO,this.GameObject.gameForegroundObjects[this.index].index=this.index,this.index++},this.moveDown=function(){if(0===this.index)return console.log("ForegroundObject #"+this.uniqueID+" is already at the bottom of the render stack!"),void console.info(this);var otherFGO=this.GameObject.gameForegroundObjects[this.index-1];this.GameObject.gameForegroundObjects[this.index-1]=this.GameObject.gameForegroundObjects[this.index],this.GameObject.gameForegroundObjects[this.index]=otherFGO,this.GameObject.gameForegroundObjects[this.index].index=this.index,this.index--},this.sendToBack=function(){for(;0!==this.index;)this.moveDown()},this.sendToFront=function(){for(;this.index!==this.gameForegroundObjects.length-1;)this.moveUp()},options.type&&(this.type=options.type),options.color&&(this.color=options.color),"function"==typeof options.updateFrame&&(this.updateFrame=options.updateFrame),"function"==typeof options.drawFrame&&(this.drawFrame=options.drawFrame),"function"==typeof options.preDrawFrame&&(this.preDrawFrame=options.preDrawFrame),"function"==typeof options.postDrawFrame&&(this.postDrawFrame=options.postDrawFrame)}function GameSprite(url,frameW,frameH,columns,rows,options={}){options.debugLogCreation&&console.log("Creating new generic sprite with these attributes.\nurl: "+url+"\nframeW: "+frameW+"\nframeH: "+frameH+"\ncolumns: "+columns+"\nrows:"+rows+"\noptions: "+options),this.uniqueSprite=!0;for(let i=0;i<Sprite.spriteRegistration.length;++i)if(Sprite.spriteRegistration[i].url===url){options.debugLogCreation&&console.log("Sprite created with existing image"),this.image=Sprite.spriteRegistration[i].image,this.uniqueSprite=!1;break}this.image||(options.debugLogCreation&&console.log("Sprite created with new image"),this.image=new Image,this.image.src=url),this.frameW=frameW,this.frameH=frameH,this.cols=columns,this.rows=rows,this.url=url,this.endFrame=rows*columns-1,this.startFrame=0,this.render=function(game,x,y,scale=1){Sprite.render(this,game,x,y,scale)},this.nextFrame=function(){this.frame++,this.frame>this.endFrame&&(this.frame=this.startFrame)},this.prevFrame=function(){this.frame--,this.frame<this.startFrame&&(this.frame=this.endFrame)},options.endFrame&&(this.endFrame=options.endFrame),options.startFrame&&(this.startFrame=options.startFrame),"function"==typeof options.render&&(this.render=options.render),"function"==typeof options.nextFrame&&(this.nextFrame=option.nextFrame),"function"==typeof options.prevFrame&&(this.prevFrame=option.prevFrame),this.frame=this.startFrame,this.uniqueSprite&&Sprite.spriteRegistration.push(this)}Sprite={render:function(sprite,game,x,y,scale=1){var cellRow=Math.floor(sprite.frame/sprite.rows),cellCol=Math.floor(sprite.frame%sprite.rows);game.pen.drawImage(sprite.image,cellCol*sprite.frameW,cellRow*sprite.frameH,sprite.frameW,sprite.frameH,x,y,sprite.frameW*scale,sprite.frameH*scale)},spriteRegistration:[]};class BGObject extends GameObjectBase{
    /** * @preserve *@constructor * @param {GameCore} gameCore * @param {Scene} scene */
    constructor(gameCore,scene){super(gameCore),this.scene=scene,this.scene.entities.background.push(this)}
    /** * @preserve *@type {string} entity display color. By default this is the color of the box that * is rendered by the default implementation of the render function. */color;
    /** * @preserve *location of the foreground object within the visiable scene */
    location={x:x,y:y,originPoint:originPoint.topLeft};
    /** * @preserve *Width and height of the entity */
    dimensions={w:w,h:h}
    /** * @preserve *@type {Scene} */;scene;
    /** * @preserve *@type {ResourceFile | null} */
    resource=null;
    /** * @preserve *Gets entity's boundingBox * @returns {boundingBox} */
    getBoundingBox(){let box=new boundingBox;switch(this.location.originPoint){case originPoint.topLeft:box.left=this.location.x,box.top=this.location.y,box.right=this.location.x+this.dimensions.w,box.bottom=this.location.y+this.dimensions.h;break;case originPoint.topRight:box.left=this.location.x-this.dimensions.w,box.top=this.location.y,box.right=this.location.x,box.bottom=this.location.y+this.dimensions.h;break;case originPoint.bottomLeft:box.left=this.location.x,box.top=this.location.y-this.dimensions.h,box.right=this.location.x+this.dimensions.w,box.bottom=this.location.y;break;case originPoint.bottomRight:box.left=this.location.x-this.dimensions.w,box.top=this.location.y-this.dimensions.h,box.right=this.location.x,box.bottom=this.location.y}return box}
    /** * @preserve *Default render method: override for more advanced implementations including complex * shapes or using image based graphics like sprite sheets/tilemaps */render(){let box=this.getBoundingBox();this.gameCore.pen.fillStyle=this.color,this.gameCore.pen.fillRect(box.left,box.top,box.left+this.dimensions.w,box.top+this.dimensions.h)}}class DataEntity extends GameObjectBase{
    /** * @preserve * * @param {GameCore} gameCore * @param {Scene} scene * @param {procLoc} procLocation */
    constructor(gameCore,scene,procLocation){super(gameCore),this.scene=scene,this.procLocation=procLocation,this.scene.entities.dataEntities.push(this)}
    /** * @preserve *@type {Scene} */scene;
    /** * @preserve *@type {procLoc} Where should entity process data. */
    procLocation}const procLoc=Object.freeze({start:"___START___",afterInput:"___AFTER_INPUT___",end:"___END___"});class FGObject extends GameObjectBase{
    /** * @preserve *@constructor * @param {GameCore} gameCore * @param {Scene} scene */
    constructor(gameCore,scene){super(gameCore),this.scene=scene,this.scene.entities.foreground.push(this)}
    /** * @preserve *@type {string} entity display color. By default this is the color of the box that * is rendered by the default implementation of the render function. */color;
    /** * @preserve *location of the foreground object within the visiable scene */
    location={x:x,y:y,originPoint:originPoint.topLeft};
    /** * @preserve *Width and height of the entity */
    dimensions={w:w,h:h}
    /** * @preserve *Gets entity's boundingBox * @returns {boundingBox} */;getBoundingBox(){let box=new boundingBox;switch(this.location.originPoint){case originPoint.topLeft:box.left=this.location.x,box.top=this.location.y,box.right=this.location.x+this.dimensions.w,box.bottom=this.location.y+this.dimensions.h;break;case originPoint.topRight:box.left=this.location.x-this.dimensions.w,box.top=this.location.y,box.right=this.location.x,box.bottom=this.location.y+this.dimensions.h;break;case originPoint.bottomLeft:box.left=this.location.x,box.top=this.location.y-this.dimensions.h,box.right=this.location.x+this.dimensions.w,box.bottom=this.location.y;break;case originPoint.bottomRight:box.left=this.location.x-this.dimensions.w,box.top=this.location.y-this.dimensions.h,box.right=this.location.x,box.bottom=this.location.y}return box}
    /** * @preserve *Override to respond to collisions or other game data. */proc=null;
    /** * @preserve *Default render method: override for more advanced implementations including complex * shapes or using image based graphics like sprite sheets/tilemaps */
    render(){let box=this.getBoundingBox();this.gameCore.pen.fillStyle=this.color,this.gameCore.pen.fillRect(box.left,box.top,box.left+this.dimensions.w,box.top+this.dimensions.h)}}class boundingBox{
    /** * @preserve *@type {number} Left edge of the box */
    left;
    /** * @preserve *@type {number} Top edge of the box */
    top;
    /** * @preserve *@type {number} Right edge of the box */
    right;
    /** * @preserve *@type {number} Bottom edge of the box */
    bottom}const originPoint=Object.freeze({topLeft:0,topRight:1,bottomLeft:2,bottomRight:3});class InputAction{
    /** * @preserve *Name of the input action * @type {string} */
    keyword;
    /** * @preserve *@type {boolean} marks when an input action can be removed from the queue. */
    complete;
    /** * @preserve *@abstract * @type {function} * Process the input's action */
    proc;
    /** * @preserve *Creates an InputAction NOTE: THIS SHOULD NOT BE USED ON ITS OWN, USE 'bind' TO BOTH CREATE THE INPUT AND BIND IT * TO A GameCore!!! * @param {string} keyword Call name used to identfy this action. Ex 'up' for moving player up or 'attack' for an attack. * The same name can be used by multiple input actions thus binding multiple keys to a single action. */
    constructor(keyword){this.keyword=keyword}
    /** * @preserve *Creates a bound input that is added to the GameCore's monitored inputs * @param {GameCore} gameCore GameCore object this input is being monitored on. * @param {string} keyword keyword used to identfy this action. Ex 'up' for moving player up or 'attack' for an attack. * The same name can be used by multiple input actions thus binding multiple keys to a single action. */static queue(gameCore,keyword){if("string"!=typeof keyword)return console.log(`Input binding failed: keyword must be of type 'string' but was provided type '${typeof keyword}.'`),!1;let input=new InputAction(gameCore,keyword);return gameCore.inputQueue.push(input),!0}}class ResourceFile extends GameObjectBase{constructor(gameObject,scene){}
    /** * @preserve *File URL * @type {string} */url;
    /** * @preserve *@type {HTMLImageElement} Image associated with this resource. */
    image;
    /** * @preserve *@type {Scene} Scene this resource belongs to. */
    scene;
    /** * @preserve *Checks to see if resource is still in use and if not it will delete itself */
    proc(){let inUse=!1,entities=[];entities=entities.concat(this.scene.entities.background,this.scene.entities.foreground);for(let i=0;i<entities.length;++i){let f=entities[i],l=entities[entities.length-1-i];if(f.resource&&f.resource.uId===this.uId||l.resource&&l.resource.uId==this.uId){inUse=!0;break}}inUse||this.scene.removeResource(this.uId)}}class Scene extends GameObjectBase{
    /** * @preserve * * @param {GameCore} gameCore */
    constructor(gameCore){super(gameCore)}
    /** * @preserve *@type {string | null} allows a scene to override the GameCore background set by the GameCore * without changing it. */backgroundColor=null;
    /** * @preserve *Entities tracked by game */
    entities={foreground:foreground,background:background,resoruces:resoruces,dataEntities:dataEntities,getTotalEntities:function(types=null){if(null!==types){var selectiveTotal=0;return"string"==typeof types?this[types]&&(selectiveTotal+=this[types].length):types.forEach((entityType=>{this[entityType]&&(selectiveTotal+=this[entityType].length)})),selectiveTotal}return this.foreground.length+this.background.length+this.resoruces.length}};
    /** * @preserve *Removes a ResourceFile from loaded resources via its uId * @param {number} uId */
    removeResource(uId){for(let i=0;i<this.entities.resoruces.length;i++)if(this.entities.resoruces[i].uId==uId)return void this.entities.resoruces.splice(i,1)}proc(){this.entities.foreground.forEach((element=>{"function"==typeof element&&element.proc()}))}render(){(this.backgroundColor||this.backgroundColor!==this.gameCore.backgroundColor)&&(this.gameCore.pen.fillStyle=this.backgroundColor,this.gameCore.pen.fillRect(0,0,this.gameCore.paperSize.width,this.gameCore.paperSize.height)),this.entities.background.forEach((bgEntity=>{"function"==typeof bgEntity.render&&bgEntity.render()})),this.entities.foreground.forEach((fgEntity=>{"function"==typeof fgEntity.render&&fgEntity.render()}))}}